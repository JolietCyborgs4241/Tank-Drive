// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "Robot.h"
#include "Commands/Auto.h"
#include "Commands/Auto2.h"
#include "WPIlib.h"
#include <iostream>
#include <stdio.h>
#include <unistd.h>
#include "SmartDashboard/SmartDashboard.h"
#include "SmartDashboard/SendableChooser.h"
#include "IterativeRobot.h"
// BEGIN   CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
DriveTrain* Robot::driveTrain = NULL;
OI* Robot::oi = NULL;
FeederBar* Robot::feederBar = NULL;
ShooterBox* Robot::shooterBox = NULL;
Pneumatics* Robot::pneumatics = NULL;
DoorArm* Robot::doorArm = NULL;
ShooterPosition* Robot::shooterPosition = NULL;
ServoDeploy* Robot::servoDeploy = NULL;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION


/*
	Robot() {
		table = NetworkTable::GetTable("GRIP/myContoursReport");
	}
*/
void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	driveTrain = new DriveTrain();
	feederBar = new FeederBar();
	shooterBox = new ShooterBox();
	pneumatics = new Pneumatics();
	doorArm = new DoorArm();
	oi = new OI();
	shooterPosition = new ShooterPosition;
	servoDeploy = new ServoDeploy;
	lw = LiveWindow::GetInstance();

    // create an image


	// instantiate the command used for the autonomous period
	prevTrigger = false;


/*
	//GRIP
	if (fork() == 0) {
		system("/home/lvuser/grip &");
	}
	//MORE GRIP
	std::cout << "Areas: ";

	std::vector<double> arr = table->GetNumberArray("area", llvm::ArrayRef<double>());
	for (unassigned int i = 0; i < arr. size(); i++){
		std::cout << arr[i] << " ";
	}
	Wait(1);
*/
	Chooser.AddDefault("Auto", new Auto());
	Chooser.AddObject("Auto2", new Auto2());
	frc::SmartDashboard::PutData("Auto Modes", &Chooser);
}

void Robot::DisabledInit() {
}

void Robot::DisabledPeriodic() {

}
	
void Robot::AutonomousInit() {
	autonomousCommand.reset(Chooser.GetSelected());
	if(autonomousCommand.get() !=nullptr)
	autonomousCommand->Start();
}
	
void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();
/*	//GRIP
	auto grip = NetworkTable::GetTable("grip");

	auto areas = grip->GetNumberArray("targets/area", llvm::ArrayRef<double>());
		for (auto area : areas) {
			std::cout << "Got contour with area=" << area << endl;
		}
		*/
}
	
void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to 
	// continue until interrupted by another command, remove
	// this line or comment it out.
	cycleTime = GetClock();
	incnum = 1;
}
	
void Robot::TeleopPeriodic() {
	SMDB();



	SmartDashboard::PutNumber("CycleTime", GetClock() - cycleTime);
	cycleTime = GetClock();


/******************DRIVETRAIN**************************************/	

//	driveTrain->Drive(oi::driverJoystickRight);

//	driveTrain->Lock();
	Scheduler::GetInstance()->Run();

}
void Robot::TestPeriodic() {
	lw->Run();
}

void Robot::SMDB()
{
	SmartDashboard::PutNumber("ShooterAngle",shooterBox->ShooterAngle->GetAverageVoltage());
}

START_ROBOT_CLASS(Robot);
